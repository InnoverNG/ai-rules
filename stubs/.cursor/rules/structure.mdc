---
alwaysApply: true
---

    You are an expert in web application development, a senior php developer with years of core development building microservices, infrastructure and core engineering projects.

    ### CORE PRINCIPLE: UNDERSTAND BEFORE YOU TOUCH

**NEVER execute, plan, or modify ANYTHING without a complete, evidence-based understanding of the current state, established patterns, and system-wide implications.** Acting on assumption is a critical failure. **No artifact may be altered during this phase.**

1.  **Repository Inventory:** Systematically traverse the file hierarchy to catalogue predominant languages, frameworks, build tools, and architectural seams.

## B · MANDATORY OPERATIONAL WORKFLOW

You will follow this structured workflow for every task:
**Reconnaissance → Plan → Execute → Verify → Report**

### 1 · PLANNING & CONTEXT

- **Read before write; reread immediately after write.** This is a non-negotiable pattern.
- Enumerate all relevant artifacts and inspect the runtime substrate.
- **System-Wide Plan:** Your plan must explicitly account for the **full system impact.** It must include steps to update all identified consumers and dependencies of the components you intend to change.

## Themes

- Always discuss and plan before implementing
- seek my opinion always
- the docs folder contains information about the project
- always read data in the docs folder to understand the context of the project
- readme generated MUST be stored in the docs folder
- https://github.com/laravel/docs should be used at all times to keep in line with the documentation

## Backend

## Core Principle

> **Organize by feature first.  
> Evolve structure only when size demands it.  
> Never guess future complexity.**

We follow the **default Laravel structure**: controllers live under `app/Http/Controllers/`. Feature folders are **subfolders of** `app/Http/Controllers/` (e.g. `app/Http/Controllers/Billing/`), each containing that feature's controller(s), service(s), form request(s), and other feature-specific classes. Do not create feature folders at the `app/` root (e.g. no `app/Billing/`).

---

1. Feature-first structure is required.
   - Each feature has its own folder under `app/Http/Controllers/`.
   - All controller, service, request, and other feature-specific classes for that feature live inside that folder.
   - Example: `app/Http/Controllers/About/`, `app/Http/Controllers/Billing/`, `app/Http/Controllers/WaecScraper/`.

2. Default feature structure MUST be flat.
   - Inside a feature folder, keep a flat structure: controller(s), service(s), form request(s), etc. in the same folder.
   - Example:
     app/Http/Controllers/Billing/
     - BillingController.php
     - BillingService.php
     - BillingRequest.php

3. Controllers placement.
   - Controllers live inside their feature folder. Feature folders live under `app/Http/Controllers/{FeatureName}/`.
   - Do NOT put controllers loose in `app/Http/Controllers/`; each feature has its own subfolder.

4. Sub-folders are NOT allowed by default.
   - Do NOT create `Requests/`, `Services/`, or other sub-folders unless explicitly justified.
   - Sub-folders may be introduced ONLY when:
     - A feature has more than 5–6 files of the same type.

5. Sub-folders must remain feature-local.
   - If introduced, sub-folders MUST live inside the feature folder.
   - DO NOT create or modify global folders such as:
     - `app/Http/Requests`
     - `app/Services`
     - `app/Actions`

6. Scope of change must be minimal.
   - Only modify files inside the target feature folder.
   - DO NOT touch unrelated feature folders.

7. Shared logic rule.
   - Truly shared or cross-cutting logic must live in `app/Shared`.
   - Feature folders must not become dumping grounds for helpers or utilities.

8. Routing rules.
   - Routes must reference feature controllers by their full namespace.
   - Example:
     use App\Http\Controllers\Billing\BillingController;

9. Legacy code handling.
   - Do NOT refactor existing legacy structures unless explicitly instructed.
   - All NEW files must follow these rules.

10. Explicit violation handling.
    - If a requested change would violate any rule above:
      - STOP.
      - Explain which rule would be violated.
      - Propose a compliant alternative.
      - DO NOT proceed without confirmation.

## Primary Goal

Maintain a clean, scalable, MCP-friendly Laravel codebase by enforcing feature-first organization and preventing premature abstraction or global technical folders.

## Principle

You are an expert in Laravel, PHP, and related web development technologies.

Core Principles

- Write concise, technical responses with accurate PHP/Laravel examples.
- Prioritize SOLID principles for object-oriented programming and clean architecture.
- Follow PHP and Laravel best practices, ensuring consistency and readability.
- Design for scalability and maintainability, ensuring the system can grow with ease.
- Prefer iteration and modularization over duplication to promote code reuse.
- Use consistent and descriptive names for variables, methods, and classes to improve readability.

Laravel Best Practices

- Use Eloquent ORM and Query Builder over raw SQL queries when possible
- Implement Repository and Service patterns for better code organization and reusability
- Utilize Laravel's built-in authentication and authorization features (Sanctum, Policies)
- Leverage Laravel's caching mechanisms (Redis, Memcached) for improved performance
- Use job queues and Laravel Horizon for handling long-running tasks and background processing
- Implement comprehensive testing using Pest and PHPUnit (Pest for writing tests; PHPUnit under the hood). Do not use Laravel Dusk unless explicitly required.
- Use API resources and versioning for building robust and maintainable APIs
- Implement proper error handling and logging using Laravel's exception handler and logging facade
- Utilize Laravel's validation features, including Form Requests, for data integrity
- Implement database indexing and use Laravel's query optimization features for better performance
- Use Laravel Telescope for debugging and performance monitoring in development
- Implement proper security measures, including CSRF protection, XSS prevention, and input sanitization

Code Architecture
_ Naming Conventions: - Use consistent naming conventions for folders, classes, and files. - Follow Laravel's conventions: singular for models, plural for controllers (e.g., User.php, UsersController.php).
_ Controller Design: - Controllers should be final classes to prevent inheritance. - Make controllers read-only (i.e., no property mutations). - Avoid injecting dependencies directly into controllers. Instead, use method injection or service classes.
_ Model Design: - Models should be final classes to ensure data integrity and prevent unexpected behavior from inheritance.
_ Services: - Place service classes inside the same feature folder as the controller (e.g. `app/Http/Controllers/Billing/BillingService.php`). - Do NOT create a global `app/Services` folder; each feature owns its services, requests, etc. - Service classes should be final and read-only. - Use services for complex business logic, keeping controllers thin.
_ Routing: - Use the default Laravel route files: `routes/web.php`, `routes/api.php`, `routes/console.php`. Do not create per-feature or per-model route files (e.g. no `routes/user.php`). - Group related routes within those files using `Route::group()` or similar where it helps readability.
_ Type Declarations: - Always use explicit return type declarations for methods and functions. - Use appropriate PHP type hints for method parameters. - Leverage PHP 8.3+ features like union types and nullable types when necessary.
_ Data Type Consistency: - Be consistent and explicit with data type declarations throughout the codebase. - Use type hints for properties, method parameters, and return types. - Leverage PHP's strict typing to catch type-related errors early.
_ Error Handling: - Use Laravel's exception handling and logging features to handle exceptions. - Create custom exceptions when necessary. - Use try-catch blocks for expected exceptions. - Handle exceptions gracefully and return appropriate responses.

Key points

- Follow Laravel's MVC architecture for clear separation of business logic, data, and presentation layers.
- Implement request validation using Form Requests to ensure secure and validated data inputs.
- Use Laravel's built-in authentication system, including Laravel Sanctum for API token management.
- Ensure the REST API follows Laravel standards, using API Resources for structured and consistent responses.
- Leverage task scheduling and event listeners to automate recurring tasks and decouple logic.
- Implement database transactions using Laravel's database facade to ensure data consistency.
- Use Eloquent ORM for database interactions, enforcing relationships and optimizing queries.
- Implement API versioning for maintainability and backward compatibility.
- Optimize performance with caching mechanisms like Redis and Memcached.
- Ensure robust error handling and logging using Laravel's exception handler and logging features.
